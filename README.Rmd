---
output: github_document
---

```{r, include = FALSE}
lgr::get_logger("mlr3")$set_threshold("warn")
set.seed(1)
options(datatable.print.class = FALSE, datatable.print.keys = FALSE)
```

# mlr3fda

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
[![RCMD Check](https://github.com/mlr-org/mlr3fda/actions/workflows/rcmdcheck.yaml/badge.svg)](https://github.com/mlr-org/mlr3fda/actions/workflows/rcmdcheck.yaml)
[![CRAN status](https://www.r-pkg.org/badges/version/mlr3fda)](https://CRAN.R-project.org/package=mlr3fda)
<!-- badges: end -->

The goal of mlr3fda is to extend `mlr3` to
[functional data](https://en.wikipedia.org/wiki/Functional_data_analysis).
We use the `tfd_reg` and `tfd_irreg` datatypes that are defined in the [tf](https://github.com/tidyfun/tf) R package.

## Installation

This package is not yet on CRAN, you can install the development version of `mlr3fda` from [GitHub](https://github.com/) with:

```{r, eval = FALSE}
# install.packages("devtools")
devtools::install_github("mlr-org/mlr3fda")
```

## Example

After loading `mlr3fda` two new feature types are available.

```{r task_feature_types}
library(mlr3)
mlr_reflections$task_feature_types

library(mlr3fda)
mlr_reflections$task_feature_types
```

The data types are:

  * `tfd_irreg` - irregular functional data, i.e. the function of each observation is observed for potentially different values.
  * `tfd_reg` - regular functional data, i.e. the function of each observation is observed for the same values.

For tutorials on how to create functional data, see the [documentation](https://github.com/tidyfun/tf) of the tf package.

Here we will start with the predefined fuel task, that has two regular functional columns as features.

```{r data, dpi = 300}
task = tsk("fuel")
task
```

Currently there are no `Learner`s that directly operate on functional data.
However, it is possible to extract simple functional features using the `PipeOpFFS`, which in the example below calculates the average functional responses.

```{r ffs, fig.width = 5, fig.height = 3}
library(mlr3pipelines)

po_fmean = po("ffs", feature = "mean")

task_fmean = po_fmean$train(list(task))[[1L]]
task_fmean$head()
```

This can be combined with a `Learner` into a complete `Graph`.
We have to set `drop = TRUE`, so that the original functional features are removed from the task.

```{r graph}
ids = partition(task)

# drop = TRUE means we remove the functional columns as features
graph = po("ffs", feature = "mean", drop = TRUE) %>>%
  po("learner", learner = lrn("regr.rpart"))

glrn = as_learner(graph)

glrn$train(task, row_ids = ids$train)

glrn$predict(task, row_ids = ids$test)
```


